# コンテナ数削減によるリソース効率化の理由と CPU 使用率への影響

## コンテナ数削減がリソース効率化につながる理由

### 1. コンテナ自体のオーバーヘッド削減
各コンテナは実行に必要な最小限のシステムリソースを消費します：
- **基本メモリ消費**: 各コンテナはベースイメージ、ランタイム、システムライブラリに対して個別にメモリを消費
- **プロセス管理オーバーヘッド**: 各コンテナは独立したプロセス空間を持ち、OSがそれぞれを管理するためのリソースが必要

```
【現状】3つのコンテナ
コンテナ1: ベースメモリ消費 ~50-100MB + アプリメモリ
コンテナ2: ベースメモリ消費 ~50-100MB + アプリメモリ
コンテナ3: ベースメモリ消費 ~50-100MB + アプリメモリ

【モジュラモノリス】1つのコンテナ
コンテナ1: ベースメモリ消費 ~50-100MB + アプリメモリ（統合）
```

### 2. 通信オーバーヘッドの排除
サービス間通信がHTTP/RESTからプロセス内関数呼び出しに変わることで：
- **ネットワークスタック処理の削減**: TCP/IPスタック処理、HTTP処理などが排除される
- **シリアライズ/デシリアライズの排除**: JSONなどのフォーマット変換処理が不要になる
- **コンテキストスイッチの削減**: プロセス間通信よりもスレッド内/プロセス内通信の方が効率的

```
【現状】マイクロサービス間通信
Client → HTTP → Chatbot → HTTP → Vector DB → 処理 → HTTP → Chatbot → HTTP → LLM → 処理 → HTTP → Chatbot → HTTP → Client

【モジュラモノリス】プロセス内通信
Client → HTTP → Chatbot → 関数呼び出し → Vector DB → 処理 → 結果返却 → LLM → 処理 → 結果返却 → HTTP → Client
```

### 3. リソース共有の効率化
- **ライブラリの重複排除**: 複数コンテナで使用される同じライブラリが一度だけメモリにロードされる
- **キャッシュの共有**: プロセス内でのデータキャッシュが可能になり、重複データ保持が減少
- **コンテナランタイムの負担軽減**: コンテナ管理システム自体の負荷が減少

## Vector DBサービスのCPU高使用率に対する影響

### 改善する可能性がある点：

1. **通信オーバーヘッドの削減**
   - Vector DBへのリクエスト・レスポンスの処理コストが削減され、純粋な検索処理により多くのCPUリソースを割り当てられる
   - 例：1000回のベクトル検索時のHTTPオーバーヘッドがなくなるため、わずかながらCPU効率が向上

2. **メモリ効率の向上によるスワップ削減**
   - メモリ使用量が減少することで、メモリスワップ発生頻度が減り、結果としてCPU負荷が下がる可能性がある
   - 特に限られたリソースの環境では効果が顕著

3. **コンテナ起動・監視オーバーヘッドの削減**
   - コンテナランタイムによるモニタリングやヘルスチェックのオーバーヘッドが減少

### 影響が限定的または変わらない点：

1. **ベクトル検索処理自体のCPU消費**
   - ベクトル類似度計算など、Vector DBサービスのコア処理部分は変わらないため、ここでのCPU使用量は基本的に同じ
   - **主要な処理のCPU使用率は変化しない**

2. **リソース競合の可能性**
   - 単一コンテナ内で全サービスが動作するため、1つのコンテナでCPU競合が発生する可能性
   - しかしDocker ComposeでもホストのCPUは共有されているので実質的な影響は少ない

## 実際に期待できる効果

現状でVector DBサービスのCPU使用率が高い場合：

```
【改善幅の目安】
• 小規模負荷時：約5-10%のCPU効率向上
• 大規模負荷時：約2-5%のCPU効率向上
• メモリ使用量：約20-30%の削減
```

ベクトル検索はCPU集約的な処理なので、コンテナ統合による効率化はあるものの、**劇的な改善は期待しにくい**です。最も大きな効果はCPUよりも**メモリ使用量の削減**と、**運用・デプロイの簡素化**の面にあります。

重要なベクトル検索処理のパフォーマンスをさらに向上させたい場合は、アルゴリズムの最適化やベクトルDBの選定、インデックス設計の改善などを検討する方が効果的でしょう。