# グローバルマテリアライズドビューとキャッシュの違い

グローバルマテリアライズドビューとキャッシュは、どちらもパフォーマンス最適化のために使われますが、実装、管理、用途において重要な違いがあります。

## 基本的な違い

| 特性 | グローバルマテリアライズドビュー | キャッシュ |
|------|----------------------------|----------|
| **実装レイヤー** | データベース内部 | アプリケーションレイヤーまたは専用サービス |
| **データ形式** | テーブル形式（行と列） | キーバリュー形式が一般的 |
| **永続性** | ディスクに永続化される | 通常はメモリ内のみ（揮発性） |
| **アクセス方法** | SQL経由 | プログラマティックAPI経由 |
| **管理方法** | DBエンジンが管理 | アプリケーションまたはキャッシュサーバー |

## 詳細な比較

### グローバルマテリアライズドビュー
```sql
-- PostgreSQLでのマテリアライズドビュー例
CREATE MATERIALIZED VIEW global_user_permissions AS
SELECT user_id, doc_id, 'allow' as access_type
FROM complex_permission_logic_query;

-- 明示的なリフレッシュが必要
REFRESH MATERIALIZED VIEW global_user_permissions;
```

- **利点**:
  - 複雑なSQLクエリの結果を事前計算して保存
  - データベースのインデックス機能を活用可能
  - トランザクション整合性が保証される
  - DBの再起動後も保持される

- **欠点**:
  - 更新はリソース集約的（全体を再計算）
  - 常に最新データを保証するのが難しい
  - 一般的にキャッシュより更新コストが高い

### キャッシュ
```python
# Redisなどを使ったキャッシュの例
def get_user_permissions(user_id):
    cache_key = f"user_perms:{user_id}"
    
    # キャッシュルックアップ
    if redis.exists(cache_key):
        return redis.get(cache_key)
        
    # DBから取得してキャッシュ
    permissions = db.query("SELECT * FROM permissions WHERE user_id = %s", [user_id])
    redis.set(cache_key, permissions, ex=3600)  # 1時間でTTL期限切れ
    
    return permissions
```

- **利点**:
  - 非常に高速なアクセス（メモリベース）
  - 柔軟な期限設定（TTL）
  - キー単位で選択的に無効化/更新が容易
  - データベース負荷を大幅に軽減

- **欠点**:
  - サーバー再起動時にデータ消失（揮発性）
  - トランザクション整合性の保証が難しい
  - キャッシュの一貫性維持に追加ロジックが必要

## RAGシステムでの使い分け

### グローバルマテリアライズドビューの適用例
1. **全ユーザー共通のデータ**:
   - ドキュメントの基本メタデータ
   - グローバルなインデックス情報

2. **複雑な権限解決ロジック**:
   - 階層的な権限構造を持つケース
   - 複数テーブル結合を必要とする権限計算

### キャッシュの適用例
1. **ユーザー固有の計算結果**:
   - ユーザー別のアクセス可能ドキュメントリスト
   - 最近の検索クエリと結果

2. **頻繁に変わらないデータ**:
   - ユーザープロファイル
   - ドキュメントメタデータ

## 最適な組み合わせ

実際のRAGシステムでは、両方を組み合わせることが最も効果的です：

1. マテリアライズドビューで複雑な権限ロジックを事前計算
2. その結果をキャッシュに格納してアクセスを高速化
3. 権限変更時はマテリアライズドビューを更新し、関連キャッシュを無効化

この組み合わせにより、データの一貫性を確保しつつ、高速なレスポンスを実現できます。